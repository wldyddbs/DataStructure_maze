#maze_Cqueue_ver2.py

#원형큐 + 스택 정답 생성

#벽찾기 x

#텍스트 기반 UI 라이브러리
import curses
import time
from DS_maze_utils import *
from DS_class import Stack, CQueue

m = [
    '1111111111111111111111111111111111111111111111111',
    'e000100000001000000000100000100000000000000000001',
    '1110111010101011111110101010101011111110111110111',
    '1010001010101000001010101010101010000000100010001',
    '1011101110101011101010111010101010111110101011111',
    '1010001000101010001010001010001010100010101000101',
    '1010111011101010111011101011111010101011101110101',
    '1010001010001010001000100010000010001000101010001',
    '1011101010111011101010111110111111111110101011101',
    '1000100010001010001010001000100000000010100000101',
    '1010111111101110111010111011111110111010111011111',
    '1010000000100000100010100010000010101010000010001',
    '1011111110111111101011101110111010101010111110101',
    '1010001000100000001000001000101000100010100000101',
    '1010101111101111111111111011101111101110101111101',
    '1000100000001000000000100010000000101000101000001',
    '1011111111111011101110111010111010101110101011101',
    '1010000000000010100010000010101010100010101000101',
    '1011111011111110111011111110101011111010101110111',
    '1010001000100000100010000010001010000010100010001',
    '1010101110101011101110101111101010111110111011111',
    '1000100010001010001000100000001010001000101000001',
    '1111111010111110111111111111111010101011101111101',
    '1000100010100010100000000010000010100000000000101',
    '1010101110101010101011111010111010111011111111101',
    '1010001000101010101000100000100010001010000000001',
    '1011111011101010111010111111101111101010111111101',
    '1010000010001010001010001000000010001010101000101',
    '1011111110111010101111101011111110111110101010101',
    '1000000010001010100010001010001000100010101010001',
    '1111111011101010111010111110101011101010101011111',
    '1010001000101010001010000010100010001000100010001',
    '1010101110101011111010111010111111101111101111101',
    '1010100010001000100010001010100000001000101000001',
    '1010111011111110101111111010101011111010101011101',
    '1010100000000010001000000010101000000010100010001',
    '1010101110111111111011101110111111111110111110111',
    '1000100010100000001000101000100010000000100010001',
    '1111111011101110111010111011101010111111101111101',
    '1000000000101010100010000010001000100000100000111',
    '1110111010101010101111111110111011111011101010001',
    '1000001010101010100010001000001010001000001000111',
    '1011111010101010111010101011101110101110111110101',
    '1000001010100010001000101000100000100010000010001',
    '1111101010111011101111101111111110111011111011111',
    '1000001010100010100010001000100010001010000010001',
    '1011111010101110111010111010101011111010111111101',
    '1010000010000000001000000010001000000000000000001',
    '1x11111111111111111111111111111111111111111111111'
]
    
#각 줄을 2차원 리스트로 반환
maze = [list(row) for row in m]
MAZE_SIZE = 49

#전역변수로 선언
path = Stack()


#BFS-----------------------------------------------------------------------------------------------------------
def BFS(stdscr):
    s = CQueue()
    s.enqueue((1, 0, None)) #출발점 좌표

    #모든 좌표 저장을 위한 딕셔너리
    parent_coord = {}
    #현재 좌표를 key로, 부모 좌표를 value로 저장
    #시작점 부모 좌표는 None
    parent_coord[(1, 0)] = None

    while not s.isEmpty():
        here = s.dequeue()
        x, y, parent = here

        #x, y가 저장된 적이 없으면 key와 value 저장
        if (x, y) not in parent_coord:
            parent_coord[(x, y)] = parent

        #도착 지점에 도달했을 때
        if maze[x][y] == 'x':
            cur = (x, y)
            while cur is not None:
                path.push(cur)
                cur = parent_coord[cur]

            printMaze(stdscr,maze) #최종 지도 유지
            stdscr.addstr("도착!", curses.A_BOLD)
            print(s)
            stdscr.refresh()
            stdscr.getch()  # 사용자 입력 대기
            return True

        #방문을 공백으로 표시
        maze[x][y] = ' '  
        printMaze(stdscr,maze) #미로 출력
        print(s) #스택 출력
        time.sleep(0.01)

        #이동 가능한 방향 확인 후 스택에 푸시
        if isValidPos(x, y-1,maze,MAZE_SIZE): s.enqueue((x, y-1,(x, y)))
        if isValidPos(x, y+1,maze,MAZE_SIZE): s.enqueue((x, y+1,(x, y)))
        if isValidPos(x-1, y,maze,MAZE_SIZE): s.enqueue((x-1, y,(x, y)))
        if isValidPos(x+1, y,maze,MAZE_SIZE): s.enqueue((x+1, y,(x, y)))

    printMaze(stdscr)
    stdscr.addstr("길을 찾을 수 없음")
    stdscr.refresh()
    stdscr.getch() #사용자 입력 대기 
    return False



#CORRECT PATH------------------------------------------------------------------------------------------
def correct_path(stdscr):
        while not path.isEmpty():
            x,y = path.pop()
            maze[x][y]='+'
            printMaze(stdscr,maze) #미로 출력
            print(path)
            time.sleep(0.01)
            
        stdscr.refresh()
        stdscr.getch() #사용자 입력 대기
        return True

curses.wrapper(BFS)

curses.wrapper(correct_path)